<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Jangalang Map Editor</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{
    --panel-w: 320px;
    --accent: #2b8cff;
    --bg: #0f1720;
    --muted: #9aa6b2;
    --card: #0b1220;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:#e6eef6;font-family:Inter,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  .wrap{display:flex;height:100%;gap:12px;padding:12px;box-sizing:border-box}
  .left{flex:1;display:flex;flex-direction:column;gap:8px}
  .canvas-wrap{background:var(--card);border-radius:8px;padding:12px;display:flex;flex-direction:column;align-items:center;gap:8px}
  canvas{background:#07101a;border:1px solid rgba(255,255,255,0.04);display:block}
  .controls{width:var(--panel-w);display:flex;flex-direction:column;gap:8px}
  .card{background:#071622;border-radius:8px;padding:12px;border:1px solid rgba(255,255,255,0.03)}
  .tool-buttons{display:flex;gap:6px;flex-wrap:wrap}
  button,select,input[type=number]{background:transparent;border:1px solid rgba(255,255,255,0.06);color:inherit;padding:8px 10px;border-radius:6px;cursor:pointer}
  button.active{border-color:var(--accent);box-shadow:0 0 0 3px rgba(43,140,255,0.08)}
  label{display:block;font-size:13px;color:var(--muted);margin-bottom:6px}
  .row{display:flex;gap:8px;align-items:center}
  textarea{width:100%;height:200px;background:#041018;color:#cfe7ff;border-radius:6px;padding:8px;border:1px solid rgba(255,255,255,0.03);resize:vertical}
  .small{font-size:12px;color:var(--muted)}
  .footer{display:flex;gap:8px;justify-content:space-between;align-items:center}
  .hint{font-size:12px;color:var(--muted)}
  input[type=file]{display:none}
</style>
</head>
<body>
<div class="wrap">
  <div class="left">
    <div class="canvas-wrap card">
      <div class="row" style="width:100%;justify-content:space-between;align-items:center">
        <div><strong>Map Canvas</strong> <span class="small">(click/drag to edit)</span></div>
        <div class="small hint">Snap grid: <span id="gridLabel">32</span> px</div>
      </div>
      <canvas id="mapCanvas" width="800" height="800"></canvas>
      <div class="row" style="width:100%;justify-content:center">
        <div class="small">Left-click: draw / place spawn · Right-click: erase</div>
      </div>
    </div>

    <div class="card" style="margin-top:8px">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div><strong>Preview</strong></div>
        <div class="small hint">Live JSON</div>
      </div>
      <textarea id="jsonPreview" readonly></textarea>
    </div>
  </div>

  <div class="controls">
    <div class="card">
      <div><strong>Tools</strong></div>
      <div class="tool-buttons" style="margin-top:8px">
        <button id="toolDraw" class="active">Draw Wall</button>
        <button id="toolSpawn">Spawn</button>
        <button id="toolErase">Erase</button>
        <button id="toolMove">Pan</button>
      </div>
      <div style="margin-top:10px" class="small">Tips: Click-drag to draw walls. Click to place spawn. Right-click to erase nearest wall.</div>
    </div>

    <div class="card">
      <div><strong>Map / Grid</strong></div>
      <div style="margin-top:8px" class="row">
        <label for="gridSize">Grid size (px)</label>
        <input id="gridSize" type="number" value="32" min="4" max="256" />
      </div>
      <div style="margin-top:8px" class="row">
        <label for="canvasSize">Canvas size (px)</label>
        <select id="canvasSize">
          <option value="512">512×512</option>
          <option value="640">640×640</option>
          <option value="800" selected>800×800</option>
          <option value="1024">1024×1024</option>
        </select>
      </div>
      <div style="margin-top:8px" class="row">
        <button id="clearBtn">Clear</button>
        <button id="centerSpawn">Center Spawn</button>
      </div>
    </div>

    <div class="card">
      <div><strong>File</strong></div>
      <div style="margin-top:8px" class="row">
        <button id="exportBtn">Export JSON</button>
        <button id="importBtn">Import JSON</button>
        <input id="fileInput" type="file" accept=".json" />
      </div>
      <div style="margin-top:8px" class="small">Filename will be map.json by default.</div>
    </div>

    <div class="card">
      <div><strong>Actions</strong></div>
      <div style="margin-top:8px" class="row">
        <button id="undoBtn">Undo</button>
        <button id="redoBtn">Redo</button>
      </div>
    </div>

    <div class="card small">
      <div><strong>Format</strong></div>
      <pre style="margin:8px 0 0 0;white-space:pre-wrap;font-size:12px;color:#bfe0ff">{"spawn":[{"x":500,"y":500}],"walls":[{"x1":100,"y1":100,"x2":700,"y2":100},...]}</pre>
    </div>
  </div>
</div>

<script>
/* Simple grid map editor for JSON maps:
   - spawn: array (we'll keep 1 spawn, but format supports more)
   - walls: array of {x1,y1,x2,y2} in map pixel coordinates
*/

const canvas = document.getElementById('mapCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
let gridSize = parseInt(document.getElementById('gridSize').value, 10) || 32;
const jsonPreview = document.getElementById('jsonPreview');

let tool = 'draw'; // draw | spawn | erase | move
const toolButtons = {
  draw: document.getElementById('toolDraw'),
  spawn: document.getElementById('toolSpawn'),
  erase: document.getElementById('toolErase'),
  move: document.getElementById('toolMove'),
};
Object.entries(toolButtons).forEach(([k,btn])=>{
  btn.addEventListener('click', ()=> setTool(k));
});
function setTool(t){
  tool=t;
  Object.values(toolButtons).forEach(b=>b.classList.remove('active'));
  if(toolButtons[t]) toolButtons[t].classList.add('active');
  canvas.style.cursor = (t==='move' ? 'grab':'crosshair');
}

document.getElementById('gridSize').addEventListener('change', (e)=>{
  gridSize = Math.max(4, Math.min(256, parseInt(e.target.value,10)||32));
  document.getElementById('gridLabel').innerText = gridSize;
  draw();
});
document.getElementById('canvasSize').addEventListener('change',(e)=>{
  const s = parseInt(e.target.value,10);
  canvas.width = s; canvas.height = s; draw();
});
document.getElementById('clearBtn').addEventListener('click', ()=>{ map.walls=[]; map.spawn=[]; pushHistory(); draw(); });
document.getElementById('centerSpawn').addEventListener('click', ()=>{ map.spawn = [{x:Math.floor(canvas.width/2), y:Math.floor(canvas.height/2)}]; pushHistory(); draw(); });

document.getElementById('exportBtn').addEventListener('click', exportJSON);
document.getElementById('importBtn').addEventListener('click', ()=>document.getElementById('fileInput').click());
document.getElementById('fileInput').addEventListener('change', handleFileImport);

document.getElementById('undoBtn').addEventListener('click', undo);
document.getElementById('redoBtn').addEventListener('click', redo);

function handleFileImport(e){
  const f = e.target.files[0];
  if(!f) return;
  const reader = new FileReader();
  reader.onload = () => {
    try {
      const m = JSON.parse(reader.result);
      if(Array.isArray(m.walls) || Array.isArray(m.spawn)){
        // normalize
        map.walls = (m.walls||[]).map(w=>({x1:+w.x1,y1:+w.y1,x2:+w.x2,y2:+w.y2}));
        map.spawn = (m.spawn||[]).map(s=>({x:+s.x,y:+s.y}));
        pushHistory();
        draw();
      } else {
        alert('Invalid map format');
      }
    } catch(err){ alert('Failed to parse JSON: '+err.message); }
  };
  reader.readAsText(f);
  e.target.value = '';
}

/* map data */
const map = {
  spawn: [{x: Math.floor(canvas.width/2), y: Math.floor(canvas.height/2)}],
  walls: []
};

/* undo/redo */
let history = [];
let historyPos = -1;
function pushHistory(){
  // deep clone
  history = history.slice(0, historyPos+1);
  history.push(JSON.parse(JSON.stringify(map)));
  historyPos = history.length - 1;
  updateButtons();
  updatePreview();
}
function undo(){ if(historyPos>0){ historyPos--; Object.assign(map, JSON.parse(JSON.stringify(history[historyPos]))); draw(); updateButtons(); updatePreview(); } }
function redo(){ if(historyPos < history.length -1){ historyPos++; Object.assign(map, JSON.parse(JSON.stringify(history[historyPos]))); draw(); updateButtons(); updatePreview(); } }
function updateButtons(){
  document.getElementById('undoBtn').disabled = historyPos <= 0;
  document.getElementById('redoBtn').disabled = historyPos >= history.length-1;
}

/* helpers */
function snap(v){ return Math.round(v / gridSize) * gridSize; }
function dist2(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; }

// nearest wall to point (returns index and distance)
function findNearestWall(pt, threshold=16){
  let best = {idx:-1, d2:Infinity};
  for(let i=0;i<map.walls.length;i++){
    const w = map.walls[i];
    // distance from pt to segment
    const x1=w.x1, y1=w.y1, x2=w.x2, y2=w.y2;
    const dx=x2-x1, dy=y2-y1;
    let t = ((pt.x-x1)*dx + (pt.y-y1)*dy) / (dx*dx+dy*dy || 1);
    t = Math.max(0, Math.min(1, t));
    const cx = x1 + t*dx, cy = y1 + t*dy;
    const d2 = (pt.x-cx)*(pt.x-cx) + (pt.y-cy)*(pt.y-cy);
    if(d2 < best.d2){ best = {idx:i,d2:d2}; }
  }
  return best.d2 <= threshold*threshold ? best.idx : -1;
}

/* drawing / interaction */
let isDown=false, startPt=null, dragPt=null;
let panOffset = {x:0,y:0}, panStart=null;

/* mouse <-> canvas coords with pan */
function toCanvas(e){
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left);// - panOffset.x;
  const y = (e.clientY - rect.top);// - panOffset.y;
  return {x: x, y: y};
}

canvas.addEventListener('mousedown', (ev) => {
  ev.preventDefault();
  if(ev.button === 2){ // right click -> erase
    const p = toCanvas(ev);
    const idx = findNearestWall(p, 12);
    if(idx >= 0){ map.walls.splice(idx,1); pushHistory(); draw(); }
    return;
  }
  isDown = true;
  startPt = toCanvas(ev);
  if(tool === 'spawn'){
    // place spawn (single spawn)
    const s = {x: snap(startPt.x), y: snap(startPt.y)};
    map.spawn = [s];
    pushHistory(); draw();
    isDown=false;
  } else if(tool === 'move'){
    panStart = {x:ev.clientX, y:ev.clientY, ox:panOffset.x, oy:panOffset.y};
    canvas.style.cursor = 'grabbing';
  } else if(tool === 'erase'){
    const idx = findNearestWall(startPt, 12);
    if(idx>=0){ map.walls.splice(idx,1); pushHistory(); draw(); isDown=false; }
  } else if(tool === 'draw'){
    dragPt = startPt;
  }
});

canvas.addEventListener('mousemove', (ev) => {
  const p = toCanvas(ev);
  if(tool==='move' && isDown && panStart){
    panOffset.x = panStart.ox + (ev.clientX - panStart.x);
    panOffset.y = panStart.oy + (ev.clientY - panStart.y);
    draw();
    return;
  }
  if(isDown && tool==='draw'){
    dragPt = p;
    draw();
  }
});

canvas.addEventListener('mouseup', (ev) => {
  if(ev.button === 2) return;
  const p = toCanvas(ev);
  if(tool==='draw' && startPt && dragPt){
    const a = {x: snap(startPt.x), y: snap(startPt.y)};
    const b = {x: snap(dragPt.x), y: snap(dragPt.y)};
    // ignore zero-length
    if(!(a.x===b.x && a.y===b.y)){
      map.walls.push({x1:a.x, y1:a.y, x2:b.x, y2:b.y});
      pushHistory();
    }
  }
  isDown=false; startPt=null; dragPt=null; panStart=null;
  canvas.style.cursor = (tool==='move' ? 'grab' : 'crosshair');
  draw();
});

canvas.addEventListener('dblclick', (ev)=>{
  // double click to place spawn
  const p = toCanvas(ev);
  map.spawn = [{x: snap(p.x), y: snap(p.y)}];
  pushHistory(); draw();
});

// context menu disabled on canvas to allow right-click erase
canvas.addEventListener('contextmenu', (e)=> e.preventDefault());

function exportJSON(){
  const out = { spawn: map.spawn.map(s=>({x:Math.round(s.x), y:Math.round(s.y)})),
                walls: map.walls.map(w=>({x1:Math.round(w.x1), y1:Math.round(w.y1), x2:Math.round(w.x2), y2:Math.round(w.y2)})) };
  const blob = new Blob([JSON.stringify(out, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'map.json';
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
}

/* rendering */
function drawGrid(){
  const w = canvas.width, h = canvas.height;
  ctx.save();
  ctx.translate(panOffset.x, panOffset.y);
  ctx.clearRect(-panOffset.x, -panOffset.y, w, h);
  // subtle grid lines
  ctx.lineWidth=1;
  ctx.strokeStyle = 'rgba(255,255,255,0.04)';
  for(let gx = 0; gx <= w; gx += gridSize){
    ctx.beginPath(); ctx.moveTo(gx,0); ctx.lineTo(gx,h); ctx.stroke();
  }
  for(let gy = 0; gy <= h; gy += gridSize){
    ctx.beginPath(); ctx.moveTo(0,gy); ctx.lineTo(w,gy); ctx.stroke();
  }
  ctx.restore();
}

function draw(){
  // background
  ctx.fillStyle = '#07101a';
  ctx.fillRect(0,0,canvas.width, canvas.height);

  // grid
  drawGrid();

  ctx.save();
  ctx.translate(panOffset.x, panOffset.y);

  // draw walls
  ctx.lineWidth = 3;
  ctx.lineCap = 'round';
  for(const w of map.walls){
    ctx.strokeStyle = '#b7c6d9';
    ctx.beginPath();
    ctx.moveTo(w.x1 + 0.5, w.y1 + 0.5);
    ctx.lineTo(w.x2 + 0.5, w.y2 + 0.5);
    ctx.stroke();

    // endpoints
    ctx.fillStyle = '#7fb5ff';
    ctx.beginPath(); ctx.arc(w.x1, w.y1, 4, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(w.x2, w.y2, 4, 0, Math.PI*2); ctx.fill();
  }

  // draw spawn(s)
  for(const s of map.spawn){
    ctx.fillStyle = '#ffd064';
    ctx.beginPath();
    ctx.arc(s.x, s.y, gridSize*0.35, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = '#333';
    ctx.font = '12px sans-serif';
    ctx.fillText('SPAWN', s.x + 8, s.y - 10);
  }

  // currently drawing preview line
  if(isDown && tool==='draw' && startPt && dragPt){
    ctx.strokeStyle = '#ffd27a';
    ctx.lineWidth = 2;
    ctx.setLineDash([6,6]);
    ctx.beginPath();
    ctx.moveTo(startPt.x, startPt.y);
    ctx.lineTo(dragPt.x, dragPt.y);
    ctx.stroke();
    ctx.setLineDash([]);
    // show snapped endpoints
    const a = {x: snap(startPt.x), y: snap(startPt.y)};
    const b = {x: snap(dragPt.x), y: snap(dragPt.y)};
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    ctx.beginPath(); ctx.arc(a.x, a.y, 4,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(b.x, b.y, 4,0,Math.PI*2); ctx.fill();
  }

  ctx.restore();

  updatePreview();
}

function updatePreview(){
  const out = { spawn: map.spawn.map(s=>({x:Math.round(s.x), y:Math.round(s.y)})),
                walls: map.walls.map(w=>({x1:Math.round(w.x1), y1:Math.round(w.y1), x2:Math.round(w.x2), y2:Math.round(w.y2)})) };
  jsonPreview.value = JSON.stringify(out, null, 2);
}

/* init */
pushHistory();
draw();
document.getElementById('gridLabel').innerText = gridSize;

/* keyboard shortcuts */
window.addEventListener('keydown', (e)=>{
  if(e.key === 'z' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); undo(); }
  if(e.key === 'y' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); redo(); }
  if(e.key === '1') setTool('draw');
  if(e.key === '2') setTool('spawn');
  if(e.key === '3') setTool('erase');
  if(e.key === '4') setTool('move');
});

</script>
</body>
</html>

